from flask import Flask, Response, jsonify  # Importing necessary Flask components
import json  # For handling JSON data
import psycopg2  # For PostgreSQL database connection
from collections import defaultdict, OrderedDict  # To maintain field order in JSON response

app = Flask(__name__)

# Database connection settings
DB_SETTINGS = {
    "dbname" : "vulnerabilities_db",
    "user" : "postgres",
    "password" : "12345678",
    "host" : "localhost",
    "port" : "5432"
}

def fetch_data():
    # Fetch all data from the 'vuln' table.
    connection = psycopg2.connect(**DB_SETTINGS)
    cursor = connection.cursor()
    cursor.execute("SELECT id, title, description, severity, cve, sensor, endpoint FROM vuln;"))
    rows = cursor.fetchall()
    connection.close()
    return rows

def assign_group_tags(vulnerabilities):
    # Group vulnerabilities based on endpoint and CVE similarity.

    # Dictionary to hold groups (key: group_tag, value: list of vulnerability IDs)
    groups = defaultdict(list)
    group_counter = 1
    group_mapping = {}

    for vuln in vulnerabilities:
        vuln_id = vuln[0]
        endpoint = vuln[6]
        cve = vuln[4]

        # Check if there's an existing group with the same endpoint and CVE
        found_group = None
        for group_tag, group_ids in groups.items():
            for existing_id in group_ids:
                existing_vuln = [v for v in vulnerabilities]
        
    


    
# Flask route to provide vulnerabilities data as JSON
@app.route('/vulnerabilities', methods=['GET'])
def vulnerabilities():
    """
    Handles GET requests to the '/vulnerabilities' endpoint.
    Fetches data from the database and returns it in a formatted JSON response.
    """
    try:
        # Fetch vulnerabilities data
        vulnerabilities = get_vulnerabilities()

        # Format the data into a list of ordered dictionaries
        response = [
            OrderedDict([
                ("id", row[0]),
                ("title", row[1]),
                ("endpoint", row[6]),
                ("cve", row[4]),
                ("tag", row[7]),
                ("description", row[2]),
                ("severity", row[3]),
                ("sensor", row[5])
            ])
            for row in vulnerabilities
        ]

        # Return the JSON response with proper formatting
        return Response(json.dumps(response, indent=4), mimetype='application/json')
    except Exception as e:
        # Return error message if something goes wrong
        return Response(json.dumps({"error": str(e)}), mimetype='application/json')

# Main entry point for running the Flask app
if __name__ == '__main__':
    app.run(debug=True)  # Run the app in debug mode for development
